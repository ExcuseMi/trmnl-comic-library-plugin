<style>
  .comic-image {
    display: block;
    max-width: 100%;
    max-height: 100%;
    {% if trmnl.plugin_settings.custom_fields_values.image_filter != "none" %}
    filter: {{trmnl.plugin_settings.custom_fields_values.image_filter}};
    {% endif %}
  }
</style>

<div class="layout layout--stretch">
  {%- if comic.imageUrls.size > 0 -%}
  <div class="flex flex--col flex--center">
    <div class="flex flex--center flex--grow mb--1" id="image-container" style="overflow: hidden;">
      {%- for imageUrl in comic.imageUrls -%}
        <img src="{{ imageUrl }}" class="image comic-image image-dither" alt="Image {{ forloop.index }}" />
      {%- endfor -%}
    </div>
    {%- if trmnl.plugin_settings.custom_fields_values.show_caption != "false" and comic.caption -%}
    <div class="label label--xs label--gray" data-clamp="3">{{ comic.caption }}</div>
    {%- endif -%}
  </div>
  {%- else -%}
  <div class="flex flex--center">
    <div class="label">No images found.</div>
  </div>
  {%- endif -%}
</div>

<div class="title_bar">
  <span class="title">
    {%- if comic.source -%}
      {%- assign title_parts = comic.title | split: ' - ' -%}
      {%- assign source_parts = comic.source | split: ' - ' -%}
      
      {%- if title_parts[0] == source_parts[0] -%}
        {{ comic.source }} - {{ title_parts[1] | default: title_parts[0] }}
      {%- else -%}
        {{ comic.source }} - {{ comic.title }}
      {%- endif -%}
    {%- else -%}
      {{ comic.title }}
    {%- endif -%}
  </span>
  <span class="instance">{{trmnl.plugin_settings.instance_name |Â escape }}
  </span>
</div>


<script>
(function(global) {
  'use strict';

  const TRMNLImageLayout = {
    /**
     * Initialize the image layout system
     * @param {Object} options - Configuration options
     * @param {string} options.containerId - ID of the container element
     * @param {string} options.imageSelector - CSS selector for images
     * @param {number} options.gap - Gap between images in pixels (default: 2)
     * @param {boolean} options.splitTallImages - Whether to split very tall images (default: true)
     * @param {number} options.tallImageThreshold - Aspect ratio threshold for tall images (default: 0.4)
     * @param {number} options.loadTimeout - Timeout for image loading in ms (default: 5000)
     * @param {number} options.startDelay - Delay before starting layout in ms (default: 100)
     */
    init: function(options) {
      const config = {
        containerId: options.containerId || 'image-container',
        imageSelector: options.imageSelector || '.comic-image',
        gap: options.gap !== undefined ? options.gap : 2,
        splitTallImages: options.splitTallImages !== undefined ? options.splitTallImages : true,
        tallImageThreshold: options.tallImageThreshold || 0.4,
        loadTimeout: options.loadTimeout || 5000,
        startDelay: options.startDelay || 100
      };

      const layoutImages = () => {
        const container = document.getElementById(config.containerId);
        if (!container) return;

        const images = Array.from(container.querySelectorAll(config.imageSelector));
        if (images.length === 0) return;

        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;

        if (containerWidth === 0 || containerHeight === 0) {
          setTimeout(layoutImages, 100);
          return;
        }

        // Wait for all images to load
        const imageLoadPromises = images.map(img => {
          if (img.complete && img.naturalWidth > 0) {
            return Promise.resolve();
          }
          return new Promise(resolve => {
            const timeout = setTimeout(() => resolve(), config.loadTimeout);
            img.onload = () => {
              clearTimeout(timeout);
              resolve();
            };
            img.onerror = () => {
              clearTimeout(timeout);
              resolve();
            };
          });
        });

        Promise.all(imageLoadPromises).then(() => {
          const loadedImages = images.filter(img => img.naturalWidth > 0 && img.naturalHeight > 0);
          if (loadedImages.length === 0) return;

          // Check if single image should be split
          if (config.splitTallImages && loadedImages.length === 1) {
            const img = loadedImages[0];
            const aspectRatio = img.naturalWidth / img.naturalHeight;

            if (aspectRatio < config.tallImageThreshold) {
              TRMNLImageLayout._displayTallImageInSections(
                img, container, containerWidth, containerHeight, config.gap
              );
              return;
            }
          }

          const imageData = loadedImages.map(img => ({
            element: img,
            aspectRatio: img.naturalWidth / img.naturalHeight
          }));

          let bestLayout = null;
          let bestCoverage = 0;

          // Try column layout
          const columnLayout = TRMNLImageLayout._calculateColumnLayout(
            imageData, containerWidth, containerHeight, config.gap
          );
          if (columnLayout && columnLayout.coverage > bestCoverage) {
            bestLayout = columnLayout;
            bestCoverage = columnLayout.coverage;
          }

          // Try row layout
          const rowLayout = TRMNLImageLayout._calculateRowLayout(
            imageData, containerWidth, containerHeight, config.gap
          );
          if (rowLayout && rowLayout.coverage > bestCoverage) {
            bestLayout = rowLayout;
            bestCoverage = rowLayout.coverage;
          }

          // Try grid layouts
          if (loadedImages.length >= 2) {
            for (let cols = 1; cols <= loadedImages.length; cols++) {
              const rows = Math.ceil(loadedImages.length / cols);
              const gridLayout = TRMNLImageLayout._calculateGridLayout(
                imageData, containerWidth, containerHeight, config.gap, rows, cols
              );
              if (gridLayout && gridLayout.coverage > bestCoverage) {
                bestLayout = gridLayout;
                bestCoverage = gridLayout.coverage;
              }
            }
          }

          // Apply best layout
          if (bestLayout) {
            container.style.flexDirection = bestLayout.direction;
            container.style.flexWrap = bestLayout.wrap || 'nowrap';
            container.style.gap = config.gap + 'px';

            bestLayout.sizes.forEach((size, i) => {
              const img = loadedImages[i];
              if (img) {
                const maxWidth = Math.min(Math.floor(size.width), containerWidth);
                const maxHeight = Math.min(Math.floor(size.height), containerHeight);

                img.style.width = maxWidth + 'px';
                img.style.height = maxHeight + 'px';
                img.style.objectFit = 'contain';
                img.style.flexShrink = '0';
                img.style.display = 'block';
              }
            });
          }
        });
      };

      // Start layout
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => setTimeout(layoutImages, config.startDelay));
      } else {
        setTimeout(layoutImages, config.startDelay);
      }
    },

    // Private methods
    _displayTallImageInSections: function(img, container, containerWidth, containerHeight, gap) {
      const aspectRatio = img.naturalWidth / img.naturalHeight;
      const scaledWidth = containerWidth;
      const scaledHeight = containerWidth / aspectRatio;
      const numSections = Math.ceil(scaledHeight / containerHeight);

      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = Math.floor(img.naturalHeight / numSections);

      container.innerHTML = '';
      container.style.flexDirection = 'column';
      container.style.gap = gap + 'px';

      for (let i = 0; i < numSections; i++) {
        const sectionCanvas = document.createElement('canvas');
        const sectionCtx = sectionCanvas.getContext('2d');

        const sectionHeight = i === numSections - 1
          ? img.naturalHeight - (canvas.height * i)
          : canvas.height;

        sectionCanvas.width = img.naturalWidth;
        sectionCanvas.height = sectionHeight;

        sectionCtx.drawImage(
          img,
          0, canvas.height * i,
          img.naturalWidth, sectionHeight,
          0, 0,
          img.naturalWidth, sectionHeight
        );

        const sectComic LibraryionImg = document.createElement('img');
        sectionImg.src = sectionCanvas.toDataURL();
        sectionImg.className = img.className;
        sectionImg.style.width = '100%';
        sectionImg.style.height = 'auto';
        sectionImg.style.maxHeight = containerHeight + 'px';
        sectionImg.style.objectFit = 'contain';
        sectionImg.style.display = 'block';

        container.appendChild(sectionImg);
      }
    },

    _calculateColumnLayout: function(imageData, containerWidth, containerHeight, gap) {
      const totalGap = gap * (imageData.length - 1);
      const availableHeight = containerHeight - totalGap;

      if (availableHeight <= 0) return null;

      let totalHeight = 0;
      imageData.forEach(img => {
        totalHeight += containerWidth / img.aspectRatio;
      });

      const scale = Math.min(1, availableHeight / totalHeight);
      const sizes = imageData.map(img => ({
        width: containerWidth * scale,
        height: (containerWidth / img.aspectRatio) * scale
      }));

      const actualHeight = sizes.reduce((sum, s) => sum + s.height, 0) + totalGap;
      const actualWidth = Math.max(...sizes.map(s => s.width));

      if (actualHeight > containerHeight + 2 || actualWidth > containerWidth + 2) {
        return null;
      }

      const coverage = (actualWidth * actualHeight) / (containerWidth * containerHeight);
      return { direction: 'column', sizes, coverage };
    },

    _calculateRowLayout: function(imageData, containerWidth, containerHeight, gap) {
      const totalGap = gap * (imageData.length - 1);
      const availableWidth = containerWidth - totalGap;

      if (availableWidth <= 0) return null;

      let totalWidth = 0;
      imageData.forEach(img => {
        totalWidth += containerHeight * img.aspectRatio;
      });

      const scale = Math.min(1, availableWidth / totalWidth);
      const sizes = imageData.map(img => ({
        width: (containerHeight * img.aspectRatio) * scale,
        height: containerHeight * scale
      }));

      const actualWidth = sizes.reduce((sum, s) => sum + s.width, 0) + totalGap;
      const actualHeight = Math.max(...sizes.map(s => s.height));

      if (actualWidth > containerWidth + 2 || actualHeight > containerHeight + 2) {
        return null;
      }

      const coverage = (actualWidth * actualHeight) / (containerWidth * containerHeight);
      return { direction: 'row', sizes, coverage };
    },

    _calculateGridLayout: function(imageData, containerWidth, containerHeight, gap, rows, cols) {
      const horizontalGap = gap * (cols - 1);
      const verticalGap = gap * (rows - 1);
      const cellWidth = (containerWidth - horizontalGap) / cols;
      const cellHeight = (containerHeight - verticalGap) / rows;

      if (cellWidth <= 0 || cellHeight <= 0) return null;

      const sizes = imageData.map(img => {
        const widthScale = cellWidth / (cellHeight * img.aspectRatio);
        const heightScale = 1;
        const scale = Math.min(widthScale, heightScale, 1);

        return {
          width: cellHeight * img.aspectRatio * scale,
          height: cellHeight * scale
        };
      });

      const avgWidth = sizes.reduce((sum, s) => sum + s.width, 0) / sizes.length;
      const avgHeight = sizes.reduce((sum, s) => sum + s.height, 0) / sizes.length;
      const coverage = (avgWidth * cols * avgHeight * rows) / (containerWidth * containerHeight);

      return { direction: 'row', wrap: 'wrap', sizes, coverage };
    }
  };

  // Export to global scope
  global.TRMNLImageLayout = TRMNLImageLayout;

})(typeof window !== 'undefined' ? window : this);
</script>
<script>
  // Initialize the image layout system
  if (typeof TRMNLImageLayout !== 'undefined') {
    TRMNLImageLayout.init({
      containerId: 'image-container',
      imageSelector: '.comic-image',
      gap: 2,
      splitTallImages: true,
      tallImageThreshold: 0.4,
      loadTimeout: 5000,
      startDelay: 100
    });
  }
</script>